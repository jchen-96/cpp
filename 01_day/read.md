## 01
命名空间
class 
private public 
struct 所有的都是公共的东西

## 02 
必须有返回值(返回值类型)
参数必须严谨
const 常量
volatile 内存可见性，多线程
更严格的类型转化，不同类型的指针不可以直接复赋值，必须进行类型转换(c可以)

new 之后必须用delete删除,new的同时可以赋值
new 和delete 是cpp 内建的操作符，不需要任何头文件

内联函数不作为函数调用，而直接调用代码　　inline只是给编辑器的一个建议，优化与否取决于编辑器
内联函数适合代码少，并且大量调用

## 03
引用变量
引用代表的是变量的别名而不是地址，新建引用的时候必须要初始化
引用赋值之后不能修改，引用和原变量的的地址是一样的，说明引用不是地址
引用参数不会开辟新的空间，相当于直接在实参上操作
引用作为函数的参数，没有出栈入栈的操作，操作速度快
引用会导致实参有被修改的危险，可以加const 解决

c++ 允许定义函数的时候，提供缺省参数，如果调用函数没有提供形参，那么形参的值就是默认的缺省值
c不允许函数的重载，cpp中可以实现函数的重载，不能通过返回值重载，只能通过参数进行重载

## 模板
template<class T>
模板也可以重载


##namespace
命名空间使用的时候需要进行声明

命名空间不写名字，这样里面的函数只能在命名空间里面互相调用
静态函数只能在文件里面调用(和java还是差别挺大)

class 中一般成员变量都是私有的，成员函数对外提供服务
如果类函数返回的是成员便令的指针，为了避免被修改可返回常量指针

如果类成员变量和全局变量重名，在类的成员函数中默认访问类的成员变量
如果要在类的内部访问全局变量加上"::"关键字，函数也是这样
.h文件只写声明.cpp　文件写声明，h文件也可以写实现
类其实就是结构的数据成员加可执行代码，统一提供封装，继承，多态



## 类的作用阈

类的成员变量作用域局限与内的内部

构造函数，析构函数

构造函数的初始化成员列表

初始化成员列表只能在构造函数使用

const 成员　必须用初始化成员列表赋初值
引用必须用初始化成员列表赋初值

构造函数可以重载

构造函数中怎么new的，析构函数中需要对应删除

析构函数只有一个

对于析构函数，所以在不同的构造函数里面给成员变量分配指针内存的时候，一定要统一

## 拷贝

浅拷贝:两个变量之间的变量的简单赋值

如果都是基础类型，
浅拷贝是没有问题的，指针引用类型，数组会出问题


深拷贝，会拷贝内存

## const
常量类成员（出事列表初始化）

常对象，意味着所有的成员都是常量，成员函数声明尾部，需要加const,告诉编译器，不会改变成员变量的值

不建议将类作为变量传递，传指针或者引用效率比较高　

在函数的参数如果是一个类，使用类的引用，如果不想类被修改,添加const

## explicit
构造函数必须严格的对应调用，不让编译器自作聪明

this 就是指向自己实例的指针　和java中类似

## static
静态变量在静态区里面，动态变量在栈里面
静态变量程序一开始就初始化，结束才销毁，只初始化一次

类的静态成员变量初始化需要在类的外部初始化，所有类的实例共享这一个静态变量

静态成员函数不能操作动态成员变量

## 类单例的实现






















